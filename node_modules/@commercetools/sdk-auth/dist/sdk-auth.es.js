import defaultsDeep from 'lodash.defaultsdeep';

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function encode(obj, pfx) {
  var k,
      i,
      tmp,
      str = '';

  for (k in obj) {
    if ((tmp = obj[k]) !== void 0) {
      if (Array.isArray(tmp)) {
        for (i = 0; i < tmp.length; i++) {
          str && (str += '&');
          str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp[i]);
        }
      } else {
        str && (str += '&');
        str += encodeURIComponent(k) + '=' + encodeURIComponent(tmp);
      }
    }
  }

  return (pfx || '') + str;
}

function toValue(mix) {
  if (!mix) return '';
  var str = decodeURIComponent(mix);
  if (str === 'false') return false;
  if (str === 'true') return true;
  return +str * 0 === 0 ? +str : str;
}

function decode(str) {
  var tmp,
      k,
      out = {},
      arr = str.split('&');

  while (tmp = arr.shift()) {
    tmp = tmp.split('=');
    k = tmp.shift();

    if (out[k] !== void 0) {
      out[k] = [].concat(out[k], toValue(tmp.shift()));
    } else {
      out[k] = toValue(tmp.shift());
    }
  }

  return out;
}

function defineError(statusCode, message) {
  var meta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}; // eslint-disable-next-line no-multi-assign

  this.status = this.statusCode = this.code = statusCode;
  this.message = message;
  Object.assign(this, meta);
  this.name = this.constructor.name; // eslint-disable-next-line no-proto

  this.constructor.prototype.__proto__ = Error.prototype;
  if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
}
/* eslint-disable max-len, flowtype/require-parameter-type */


function NetworkError() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  defineError.call.apply(defineError, [this, 0
  /* special code to indicate network errors */
  ].concat(args));
}

function BadRequest() {
  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }

  defineError.call.apply(defineError, [this, 400].concat(args));
}

function Unauthorized() {
  for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    args[_key4] = arguments[_key4];
  }

  defineError.call.apply(defineError, [this, 401].concat(args));
}

function Forbidden() {
  for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    args[_key5] = arguments[_key5];
  }

  defineError.call.apply(defineError, [this, 403].concat(args));
}

function NotFound() {
  for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
    args[_key6] = arguments[_key6];
  }

  defineError.call.apply(defineError, [this, 404].concat(args));
}

function ConcurrentModification() {
  for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
    args[_key7] = arguments[_key7];
  }

  defineError.call.apply(defineError, [this, 409].concat(args));
}

function InternalServerError() {
  for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
    args[_key8] = arguments[_key8];
  }

  defineError.call.apply(defineError, [this, 500].concat(args));
}

function ServiceUnavailable() {
  for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
    args[_key9] = arguments[_key9];
  }

  defineError.call.apply(defineError, [this, 503].concat(args));
}
/* eslint-enable max-len */


function getErrorByCode(code) {
  switch (code) {
    case 0:
      return NetworkError;

    case 400:
      return BadRequest;

    case 401:
      return Unauthorized;

    case 403:
      return Forbidden;

    case 404:
      return NotFound;

    case 409:
      return ConcurrentModification;

    case 500:
      return InternalServerError;

    case 503:
      return ServiceUnavailable;

    default:
      return undefined;
  }
}

var MANAGE_PROJECT = 'manage_project';
var DEFAULT_AUTH_TYPE = 'Basic';
var EXPIRATION_OFFSET = 2 * 60 * 60 * 1000; // 2 hours

var SdkAuth = /*#__PURE__*/function () {
  // Set flowtype annotations

  /**
   * Sample configuration object:
   * {
   *   "host": "https://auth.commercetools.com",
   *   "projectKey": "sample-project",
   *   "disableRefreshToken": false,
   *   "credentials": {
   *     "clientId": "sampleClient",
   *     "clientSecret": "sampleSecret"
   *   },
   *   "scopes": [
   *     "view_products:{project-key}"
   *   ],
   *   "fetch": function // implementation of a fetch method
   * }
   * @param config
   */
  function SdkAuth(config) {
    _classCallCheck(this, SdkAuth);

    // validate config properties
    SdkAuth._checkRequiredConfiguration(config);

    this.config = config;
    this.fetcher = SdkAuth._getFetcher(config.fetch); // auth endpoints

    this.ANONYMOUS_FLOW_URI = "/oauth/--projectKey--/anonymous/token";
    this.CUSTOMER_PASSWORD_FLOW_URI = "/oauth/--projectKey--/customers/token";
    this.BASE_AUTH_FLOW_URI = '/oauth/token';
    this.INTROSPECT_URI = '/oauth/introspect';
  }

  _createClass(SdkAuth, [{
    key: "_process",
    value: function _process(request) {
      return this._performRequest(request).then(function (response) {
        return SdkAuth._handleResponse(request.uri, response);
      });
    }
  }, {
    key: "_performRequest",
    value: function _performRequest(request) {
      var uri = request.uri,
          body = request.body,
          basicAuth = request.basicAuth,
          authType = request.authType,
          headers = request.headers;
      var fetchHeaders = headers || {
        Authorization: "".concat(authType || DEFAULT_AUTH_TYPE, " ").concat(basicAuth),
        'Content-Length': Buffer.byteLength(body).toString(),
        'Content-Type': 'application/x-www-form-urlencoded'
      };
      var fetchRequest = {
        method: 'POST',
        headers: fetchHeaders,
        body: body
      }; // use .call as a workaround for `TypeError: Failed to execute 'fetch' on 'Window': Illegal invocation`
      // error which occures in browser when using this class loaded by webpack and installed by yarn

      return this.fetcher.call(null, uri, fetchRequest);
    }
  }, {
    key: "_getRequestConfig",
    value: function _getRequestConfig() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var mergedConfig = defaultsDeep({}, config, this.config); // handle scopes array - defaultsDeep would merge arrays together
      // instead of taking its first occurrence

      if (config.scopes) mergedConfig.scopes = config.scopes;
      return mergedConfig;
    }
  }, {
    key: "anonymousFlow",
    value: function anonymousFlow() {
      var anonymousId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _config = this._getRequestConfig(config);

      var request = SdkAuth._buildRequest(_config, SdkAuth._enrichUriWithProjectKey(this.ANONYMOUS_FLOW_URI, _config.projectKey));

      if (anonymousId) request = SdkAuth._appendToRequestBody(request, {
        anonymous_id: anonymousId
      });
      return this._process(request);
    }
  }, {
    key: "clientCredentialsFlow",
    value: function clientCredentialsFlow() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var _config = this._getRequestConfig(config);

      var request = SdkAuth._buildRequest(_config, this.BASE_AUTH_FLOW_URI);

      return this._process(request);
    }
  }, {
    key: "_passwordFlow",
    value: function _passwordFlow(credentials, config, url) {
      var _ref = credentials || {},
          username = _ref.username,
          password = _ref.password;

      var request = SdkAuth._buildRequest(config, url, 'password');

      request = SdkAuth._appendUserCredentialsToBody(request, username, password);
      return this._process(request);
    }
  }, {
    key: "customerPasswordFlow",
    value: function customerPasswordFlow(credentials) {
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _config = this._getRequestConfig(config);

      var url = SdkAuth._enrichUriWithProjectKey(this.CUSTOMER_PASSWORD_FLOW_URI, _config.projectKey);

      return this._passwordFlow(credentials, _config, url);
    }
  }, {
    key: "clientPasswordFlow",
    value: function clientPasswordFlow(credentials) {
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _config = this._getRequestConfig(config);

      return this._passwordFlow(credentials, _config, this.BASE_AUTH_FLOW_URI);
    }
  }, {
    key: "refreshTokenFlow",
    value: function refreshTokenFlow(token) {
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (!token) throw new Error('Missing required token value');

      var _config = this._getRequestConfig(config);

      var request = SdkAuth._appendToRequestBody(SdkAuth._buildRequest(_config, this.BASE_AUTH_FLOW_URI, 'refresh_token'), {
        refresh_token: token
      });

      return this._process(request);
    }
  }, {
    key: "introspectToken",
    value: function introspectToken(token) {
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (!token) throw new Error('Missing required token value');

      var _config = this._getRequestConfig(config);

      var request = SdkAuth._appendToRequestBody(SdkAuth._buildRequest(_config, this.INTROSPECT_URI), {
        token: token
      });

      return this._process(request);
    }
  }, {
    key: "customFlow",
    value: function customFlow(requestConfig) {
      var credentials = requestConfig.credentials,
          host = requestConfig.host,
          uri = requestConfig.uri,
          body = requestConfig.body,
          token = requestConfig.token,
          authType = requestConfig.authType,
          headers = requestConfig.headers;

      var _config = this._getRequestConfig({
        host: host,
        token: token,
        authType: authType,
        headers: headers
      });

      var request = SdkAuth._buildRequest(_config, uri);

      request.body = body || ''; // let user to build their own body

      if (credentials) request = SdkAuth._appendUserCredentialsToBody(request, credentials.username, credentials.password);
      return this._process(request);
    }
  }], [{
    key: "_getFetcher",
    value: function _getFetcher(fetcher) {
      if (!fetcher && typeof fetch === 'undefined') throw new Error('`fetch` is not available. Please pass in `fetch` as an option or have it globally available.');
      var fetchFunction;

      if (fetcher) {
        fetchFunction = fetcher;
      } else {
        // `fetcher` is set here rather than the destructuring to ensure fetch is
        // declared before referencing it otherwise it would cause a `ReferenceError`.
        // For reference of this pattern: https://github.com/apollographql/apollo-link/blob/498b413a5b5199b0758ce898b3bb55451f57a2fa/packages/apollo-link-http/src/httpLink.ts#L49
        fetchFunction = fetch;
      }

      return fetchFunction;
    }
  }, {
    key: "_checkRequiredConfiguration",
    value: function _checkRequiredConfiguration(config) {
      if (!config) throw new Error('Missing required options');
      if (!config.host) throw new Error('Missing required option (host)');
      if (!config.credentials) throw new Error('Missing required option (credentials)');
      var _config$credentials = config.credentials,
          clientId = _config$credentials.clientId,
          clientSecret = _config$credentials.clientSecret;
      if (!(clientId && clientSecret)) throw new Error('Missing required credentials (clientId, clientSecret)');
    }
  }, {
    key: "_encodeClientCredentials",
    value: function _encodeClientCredentials(_ref2) {
      var clientId = _ref2.clientId,
          clientSecret = _ref2.clientSecret;
      return Buffer.from("".concat(clientId, ":").concat(clientSecret)).toString('base64');
    }
  }, {
    key: "_getScopes",
    value: function _getScopes(scopes, projectKey) {
      return scopes ? scopes.join(' ') : [MANAGE_PROJECT, projectKey].filter(Boolean).join(':'); // generate a default scope manage_project:projectKey
    }
  }, {
    key: "_buildRequest",
    value: function _buildRequest(config, oauthUri) {
      var grantType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'client_credentials';
      var projectKey = config.projectKey,
          credentials = config.credentials,
          host = config.host,
          disableRefreshToken = config.disableRefreshToken,
          scopes = config.scopes,
          headers = config.headers;

      var scope = SdkAuth._getScopes(scopes, projectKey);

      var uri = host.replace(/\/$/, '') + oauthUri;

      var basicAuth = config.token || SdkAuth._encodeClientCredentials(credentials);

      var authType = config.authType || DEFAULT_AUTH_TYPE;
      var isNotRefreshTokenGrantType = grantType !== 'refresh_token';
      var queryParams = {
        grant_type: grantType
      };

      if (disableRefreshToken) {
        queryParams.refresh_token = false;
      }

      if (isNotRefreshTokenGrantType) {
        queryParams.scope = scope;
      }

      var initialBody = encode(queryParams);
      return {
        basicAuth: basicAuth,
        authType: authType,
        uri: uri,
        body: initialBody,
        headers: headers
      };
    }
  }, {
    key: "_appendToRequestBody",
    value: function _appendToRequestBody(request, toAppend) {
      var previousDecodedRequestBody = request.body ? decode(request.body) : {};
      var nextEncodedRequestBody = encode(_objectSpread2(_objectSpread2({}, previousDecodedRequestBody), toAppend));
      request.body = nextEncodedRequestBody;
      return request;
    }
  }, {
    key: "_createResponseError",
    value: function _createResponseError(_ref3, uri, statusCode) {
      var _ref3$message = _ref3.message,
          message = _ref3$message === void 0 ? 'Unexpected non-JSON error response' : _ref3$message,
          rest = _objectWithoutProperties(_ref3, ["message"]);

      var errorMessage = statusCode === 404 ? "URI not found: ".concat(uri) : message;
      var ResponseError = getErrorByCode(statusCode);
      if (!ResponseError) ResponseError = getErrorByCode(0);
      return new ResponseError(errorMessage, rest);
    }
  }, {
    key: "_parseResponseJson",
    value: function _parseResponseJson(response) {
      return response.json().catch(function () {
        return {
          statusCode: response.status
        };
      });
    }
  }, {
    key: "_isErrorResponse",
    value: function _isErrorResponse(response) {
      return !response.status || response.status >= 400;
    }
  }, {
    key: "_calculateExpirationTime",
    value: function _calculateExpirationTime(expiresIn) {
      return Date.now() + expiresIn * 1000;
    }
  }, {
    key: "_enrichTokenResponse",
    value: function _enrichTokenResponse(response) {
      if (response.expires_in) {
        return _objectSpread2(_objectSpread2({}, response), {}, {
          // add a new property with expiration time in unixTimestamp format
          expires_at: SdkAuth._calculateExpirationTime(response.expires_in)
        });
      }

      return response;
    }
  }, {
    key: "_handleResponse",
    value: function _handleResponse(uri, response) {
      return SdkAuth._parseResponseJson(response).then(function (jsonResponse) {
        if (SdkAuth._isErrorResponse(response)) throw SdkAuth._createResponseError(jsonResponse, uri, response.status);
        return SdkAuth._enrichTokenResponse(jsonResponse);
      });
    }
  }, {
    key: "_appendUserCredentialsToBody",
    value: function _appendUserCredentialsToBody(request, username, password) {
      if (!(username && password)) throw new Error('Missing required user credentials (username, password)');
      return SdkAuth._appendToRequestBody(request, {
        username: username,
        password: password
      });
    }
  }, {
    key: "_enrichUriWithProjectKey",
    value: function _enrichUriWithProjectKey(uri, projectKey) {
      if (!projectKey) throw new Error('Missing required option (projectKey)');
      return uri.replace('--projectKey--', projectKey);
    }
  }]);

  return SdkAuth;
}();

var TokenProvider = /*#__PURE__*/function () {
  // Set flowtype annotations
  function TokenProvider(_ref) {
    var sdkAuth = _ref.sdkAuth,
        fetchTokenInfo = _ref.fetchTokenInfo,
        onTokenInfoChanged = _ref.onTokenInfoChanged,
        onTokenInfoRefreshed = _ref.onTokenInfoRefreshed;
    var tokenInfo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, TokenProvider);

    if (!sdkAuth) throw new Error('Property "sdkAuth" was not provided');
    if (tokenInfo) TokenProvider._validateTokenInfo(tokenInfo);
    this.onTokenInfoChanged = onTokenInfoChanged;
    this.onTokenInfoRefreshed = onTokenInfoRefreshed;
    this.fetchTokenInfo = fetchTokenInfo;
    this.sdkAuth = sdkAuth;
    this.tokenInfo = tokenInfo;
    this.fetchTokenInfoPromise = null;
    this.refreshTokenFlowPromise = null;
  }

  _createClass(TokenProvider, [{
    key: "_performFetchTokenInfo",
    value: function _performFetchTokenInfo() {
      var _this = this;

      if (!this.fetchTokenInfo) return Promise.reject(new Error('Method "fetchTokenInfo" was not provided')); // do not run fetchTokenInfo more than once at any given time and cache the result

      if (this.fetchTokenInfoPromise) return this.fetchTokenInfoPromise;
      this.fetchTokenInfoPromise = Promise.resolve(this.fetchTokenInfo(this.sdkAuth));
      return this.fetchTokenInfoPromise.then(function (tokenInfo) {
        _this.fetchTokenInfoPromise = null;
        return tokenInfo;
      }).catch(function (error) {
        _this.fetchTokenInfoPromise = null;
        throw error;
      });
    }
  }, {
    key: "_performRefreshTokenFlow",
    value: function _performRefreshTokenFlow(refreshToken) {
      var _this2 = this;

      // run refreshTokenFlow only once when multiple requests comes at the same time
      if (this.refreshTokenFlowPromise) return this.refreshTokenFlowPromise;
      this.refreshTokenFlowPromise = this.sdkAuth.refreshTokenFlow(refreshToken);
      return this.refreshTokenFlowPromise.then(function (refreshTokenInfo) {
        _this2.refreshTokenFlowPromise = null;
        return refreshTokenInfo;
      }).catch(function (error) {
        _this2.refreshTokenFlowPromise = null;
        throw error;
      });
    }
  }, {
    key: "_refreshToken",
    value: function _refreshToken(oldTokenInfo) {
      var _this3 = this;

      var newTokenInfo;
      if (!(oldTokenInfo === null || oldTokenInfo === void 0 ? void 0 : oldTokenInfo['refresh_token']) && !this.fetchTokenInfo) return Promise.reject(new Error('Property "refresh_token" and "fetchTokenInfo" method are missing')); // perform refreshTokenFlow if we have refresh token otherwise call getTokenInfo method

      var newTokenPromise = (oldTokenInfo === null || oldTokenInfo === void 0 ? void 0 : oldTokenInfo['refresh_token']) ? this._performRefreshTokenFlow(oldTokenInfo.refresh_token) : this._performFetchTokenInfo();
      return newTokenPromise.then(function (tokenInfo) {
        var _this3$onTokenInfoRef;

        newTokenInfo = tokenInfo;
        if (oldTokenInfo === null || oldTokenInfo === void 0 ? void 0 : oldTokenInfo['refresh_token']) newTokenInfo.refresh_token = oldTokenInfo.refresh_token;
        return (_this3$onTokenInfoRef = _this3.onTokenInfoRefreshed) === null || _this3$onTokenInfoRef === void 0 ? void 0 : _this3$onTokenInfoRef.call(_this3, newTokenInfo, oldTokenInfo);
      }).then(function () {
        return _this3.setTokenInfo(newTokenInfo);
      });
    }
    /**
     * Set current token info to null
     */

  }, {
    key: "invalidateTokenInfo",
    value: function invalidateTokenInfo() {
      this.tokenInfo = null;
    }
    /**
     * Method will return tokenInfo or if it is not provided it will call fetchTokenInfo() method
     * for retrieving the first tokenInfo
     * @returns {Promise.<TokenInfo>}
     */

  }, {
    key: "getTokenInfo",
    value: function getTokenInfo() {
      if (this.tokenInfo && !TokenProvider._isTokenExpired(this.tokenInfo)) return Promise.resolve(this.tokenInfo); // $FlowFixMe - _refreshToken method will fetch new tokenInfo if not provided

      return this._refreshToken(this.tokenInfo);
    }
  }, {
    key: "setTokenInfo",
    value: function setTokenInfo(tokenInfo) {
      var _this$onTokenInfoChan;

      TokenProvider._validateTokenInfo(tokenInfo);

      this.tokenInfo = tokenInfo;
      return Promise.resolve((_this$onTokenInfoChan = this.onTokenInfoChanged) === null || _this$onTokenInfoChan === void 0 ? void 0 : _this$onTokenInfoChan.call(this, tokenInfo)).then(function () {
        return tokenInfo;
      });
    }
  }, {
    key: "getAccessToken",
    value: function getAccessToken() {
      return this.getTokenInfo().then(function (tokenInfo) {
        return tokenInfo.access_token;
      });
    }
  }], [{
    key: "_validateTokenInfo",
    value: function _validateTokenInfo(tokenInfo) {
      if (!tokenInfo.access_token && !tokenInfo.refresh_token) throw new Error('At least one of "access_token" or "refresh_token" properties has to be provided');
    }
  }, {
    key: "_isTokenExpired",
    value: function _isTokenExpired(tokenInfo) {
      if (!tokenInfo || !tokenInfo.access_token || !tokenInfo.expires_at) return true; // token is expired if current time is bigger than expiration time minus some offset
      // NOTE: all timezones use same place of unix timestamp origin

      return Date.now() >= (tokenInfo.expires_at || 0) - EXPIRATION_OFFSET;
    }
  }]);

  return TokenProvider;
}();

export default SdkAuth;
export { TokenProvider };
